#### ── oh-my-zsh base ─────────────────────────────────────────────────────────
export ZSH="$HOME/.oh-my-zsh"
ZSH_THEME=""   # Starship renders the prompt
plugins=(git zsh-autosuggestions zsh-syntax-highlighting)  # syntax-highlighting must be last
source "$ZSH/oh-my-zsh.sh"

# Use micro as my default editor
export EDITOR="micro"     # many CLI tools read this
export VISUAL="micro"     # some tools prefer VISUAL over EDITOR
export GIT_EDITOR="micro" # Git-specific (optional; EDITOR usually enough)
export SUDO_EDITOR="$EDITOR"  # used by `sudo -e` / `sudoedit` (optional)

TMOUT=5
TRAPALRM() { zle reset-prompt }

# Autosuggestions (ghost text) dimmed
ZSH_AUTOSUGGEST_HIGHLIGHT_STYLE='fg=8'

#### ── ONE set of timestamp+duration pills on previous command line ──────────
# Requires a Nerd Font for / caps.

# Remove any old copies of our hooks so re-sourcing .zshrc won't duplicate output
autoload -Uz add-zsh-hook
add-zsh-hook -d preexec _my_preexec >/dev/null 2>&1
add-zsh-hook -d precmd  _my_precmd  >/dev/null 2>&1

# Track command start & the command name (to suppress after 'clear'/'reset')
typeset -g __cmd_start=0 __last_cmd="" __empty_cmd=0
_my_preexec() {
  __cmd_start=$EPOCHREALTIME;
  __last_cmd="${1%% *}";
  __empty_cmd=0;  # Reset empty command flag
}

# Pill renderer (caps use the same color as the pill's background)
_pill() {
  local text="$1" fg="$2" bg="$3"
  printf "\e[38;2;%sm\e[0m" "$bg"                          # left cap
  printf "\e[38;2;%s;48;2;%sm %s \e[0m" "$fg" "$bg" "$text" # body (with small inner padding)
  printf "\e[38;2;%sm\e[0m" "$bg"                          # right cap
}

# Strip ANSI for width calc
_strip_ansi() { echo -E "$1" | sed -E 's/\x1B\[[0-9;]*m//g'; }

# 1-decimal runtime with unit
__fmt_dur() {
  (( __cmd_start == 0 )) && { printf ""; return; }
  local dt=$(( EPOCHREALTIME - __cmd_start ))   # float seconds
  __cmd_start=0
  if (( dt < 0.001 )); then
    printf '%.1fµs' "$(( dt * 1000000.0 ))"
  elif (( dt < 1 )); then
    printf '%.1fms' "$(( dt * 1000.0 ))"
  elif (( dt < 60 )); then
    printf '%.1fs' "$dt"
  elif (( dt < 3600 )); then
    printf '%.1fmin' "$(( dt / 60.0 ))"
  else
    printf '%.1fh' "$(( dt / 3600.0 ))"
  fi
}

_my_precmd() {
  # Capture exit code IMMEDIATELY before anything else
  local captured_exit_code=$?
  local exit_code dur

  # Check if this is an empty command
  if (( __cmd_start == 0 )); then
    # This is an empty command - use its own values
    exit_code=0  # Empty commands are always successful
    dur="0.0ms"
  else
    # This is a real command - use captured exit code and duration
    exit_code=$captured_exit_code
    dur="$(__fmt_dur)"
    [[ -z "$dur" ]] && return
  fi

  # Suppress badge after clear/reset to avoid odd doubles after a screen wipe
  if [[ "$__last_cmd" == "clear" || "$__last_cmd" == "reset" ]]; then
    __last_cmd=""
    __cmd_start=0
    return
  fi

  # Build 12h timestamp from command START time (not completion time)
  local start_time
  if (( __cmd_start == 0 )); then
    # Empty command - use current time
    start_time=$EPOCHREALTIME
  else
    # Real command - use the start time
    start_time=$__cmd_start
  fi

  local sec=${start_time%.*}
  local frac=${start_time#*.}
  frac="${frac}000000"; frac="${frac:0:6}"                # μs padded
  local ms=$(( ( ${frac} + 500 ) / 1000 ))                # round to ms
  local ms3=$(printf "%03d" $ms)
  local base=$(strftime "%I:%M:%S %p" $sec)               # e.g., 03:52:11 PM
  local ts="${base% *}.${ms3} ${base##* }"                # 03:52:11.015 PM

  # Colors (tweak to match your Starship theme)
  local FG="5;5;15"             # dark
  local BG_TIME="96;125;139"    # blue grey
  local BG_DUR="120;144;156"    # slate grey-blue
  local BG_SUCCESS="46;125;50"  # green
  local BG_ERROR="183;28;28"    # red

  # Status indicator and unified pill content
  local status_symbol status_bg unified_content
  if (( exit_code == 0 )); then
    status_symbol="✓"
    status_bg="$BG_SUCCESS"
  else
    status_symbol="✗"
    status_bg="$BG_ERROR"
  fi

  # Create unified pill content: <symbol> <duration> <timestamp>
  unified_content="$status_symbol $dur $ts"

  # Create multi-line curved pointer structure (flipped from left side)
  local pointer_line="─╮"
  local pill_line="$(_pill "$unified_content" "$FG" "$status_bg") <─╯"

  # Calculate positioning for right alignment
  local pill_plain="$(_strip_ansi "$pill_line")"
  local pointer_plain="$(_strip_ansi "$pointer_line")"
  local pill_pad=$(( COLUMNS - ${#pill_plain} ))
  local pointer_pad=$(( COLUMNS - ${#pointer_plain} ))
  (( pill_pad < 0 )) && pill_pad=0
  (( pointer_pad < 0 )) && pointer_pad=0

  # Add status pills without overwriting content
  # Move up to last line and check if we have space for the arrow
  printf "\033[1A"                                        # Move up 1 line

  # Get current cursor position to see how much space we have
  local cursor_col
  printf "\033[6n"                                        # Query cursor position
  read -s -d R cursor_pos                                 # Read response
  cursor_col="${cursor_pos##*;}"                         # Extract column number

  # Calculate space available for arrow (add 1 for spacing)
  local arrow_width=$((${#pointer_plain} + 1))
  local space_available=$((COLUMNS - cursor_col))

  if (( space_available >= arrow_width )); then
    # Enough space - place arrow on same line with spacing
    printf "\033[%dC %s\n" "$((COLUMNS - cursor_col - arrow_width + 1))" "$pointer_line"
  else
    # Not enough space - go to next line
    printf "\n\033[%dC%s\n" "$pointer_pad" "$pointer_line"
  fi

  printf "\033[%dC%s\n" "$pill_pad" "$pill_line"         # Place pill line
  printf "\n"                                             # Add blank line before next prompt

  __last_cmd=""
  __cmd_start=0  # Reset for next command cycle
}

# Register hooks
add-zsh-hook preexec _my_preexec
add-zsh-hook precmd  _my_precmd

#### ── Starship prompt (badges line + prompt line) ────────────────────────────
eval "$(starship init zsh)"

#### ── Nice defaults ──────────────────────────────────────────────────────────
setopt autocd extendedglob
HISTFILE=~/.zsh_history
HISTSIZE=50000
SAVEHIST=50000
bindkey -e
export PATH=$PATH:$HOME/go/bin
export PATH="$HOME/bin:$PATH"

#### ── Disable annoying pagers ────────────────────────────────────────────────
export AWS_PAGER=""        # AWS CLI won't use 'less'
export PAGER=cat           # Git and other tools use cat instead of less
export GIT_PAGER=cat       # Git-specific override

# bun completions
[ -s "$HOME/.bun/_bun" ] && source "$HOME/.bun/_bun"

# bun
export BUN_INSTALL="$HOME/.bun"
export PATH="$BUN_INSTALL/bin:$PATH"
export PATH="/opt/homebrew/opt/mssql-tools18/bin:$PATH"

# after: source "$ZSH/oh-my-zsh.sh"
unalias gss 2>/dev/null   # remove OMZ git alias
hash -r                   # refresh command hash

# Set HCLOUD_TOKEN in a local .env or secrets file, not here
# export HCLOUD_TOKEN="..."

#### ── Remote block server ───────────────────────────────────────────────────
# Each invocation creates a unique tmux session (not shared between iTerm panes)
block() {
  mosh jd@100.103.247.110 -- tmux new -s "block-$(date +%s)"
}

#### ── Claude Code ──────────────────────────────────────────────────────────
alias claude='claude --dangerously-skip-permissions --chrome'
alias lclaude='claude --dangerously-skip-permissions --chrome --mcp-config $HOME/.claude/mcp-configs/linear.json'

### Clear alias
alias c='clear'
